#!/usr/bin/env python3
"""
Simple example script to listen for Sonar 3D-15 data over multicast and print out
the parsed information (including RangeImage and BitmapImageGreyscale8 messages).

REQUIREMENTS:
  - Python 3
  - protobuf (pip install protobuf)
  - sonar_3d_15_protocol_pb2.py generated from the Water Linked sonar .proto file
  - Access to the multicast IP and port used by the Sonar 3D-15
  - Internet/Firewall settings that allow UDP multicast traffic

USAGE:
  1. Place this script (e.g., "sonar_listener.py") in the same folder as the
     "sonar_3d_15_protocol_pb2.py" file (generated by protoc).
  2. Edit SONAR_IP to match your Sonar 3D-15's IP address.
  3. Run: python sonar_listener.py
  4. Observe the output in the terminal.
"""

import socket
import struct
import zlib

# Generated Protobuf definitions for the Sonar 3D-15 protocol
from sonar_3d_15_protocol_pb2 import (
    Packet,
    BitmapImageGreyscale8,
    RangeImage
)

# Multicast group and port used by the Sonar 3D-15
MULTICAST_GROUP = '224.0.0.96'
PORT = 4747

# Adjust this if you know your specific Sonar IP.
# The script will discard packets from any other source.
SONAR_IP = "10.1.2.43"  # <-- Change this to match your Sonar 3D-15's IP

# The maximum possible packet size for Sonar 3D-15 data
BUFFER_SIZE = 65535


def parse_rip1_packet(data: bytes):
    """
    Parse the RIP1 framing:
      1. Verify the "RIP1" magic header
      2. Verify total_length field matches the data size
      3. Check CRC
      4. Extract payload (proto data) from the packet

    Returns:
      payload (bytes) if valid, or None if there's an error.
    """
    if len(data) < 13:
        print(f"Packet too small: only {len(data)} bytes.")
        return None

    # First 4 bytes are "RIP1"
    magic = data[:4]
    if magic != b'RIP1':
        print(f"Invalid magic: got {magic!r} instead of b'RIP1'.")
        return None

    # Next 4 bytes (little-endian) specify the total packet length
    total_length = struct.unpack('<I', data[4:8])[0]
    if len(data) < total_length:
        print(
            f"Packet truncated: needed {total_length} bytes, got {len(data)}.")
        return None

    # The payload is between offset 8 and (total_length - 4)
    payload = data[8: total_length - 4]

    # Last 4 bytes in the packet is the CRC32
    crc_received = struct.unpack('<I', data[total_length - 4: total_length])[0]
    crc_calculated = zlib.crc32(data[: total_length - 4]) & 0xffffffff
    if crc_calculated != crc_received:
        print(
            f"CRC mismatch: expected 0x{crc_calculated:08x}, got 0x{crc_received:08x}.")
        return None

    return payload


def decode_protobuf_packet(payload: bytes):
    """
    Decode the Protobuf Packet (top-level), which may contain:
      - BitmapImageGreyscale8
      - RangeImage
      - or an unknown message type (google.protobuf.Any)

    Returns:
      (msg_type_name, message_object) if successfully parsed,
      or None if parsing failed.
    """
    # Create a top-level Packet object
    packet = Packet()
    try:
        packet.ParseFromString(payload)
    except Exception as e:
        print(f"Protobuf parse error: {e}")
        return None

    # The actual data is in the .msg field (type google.protobuf.Any)
    any_msg = packet.msg
    if not any_msg.IsInitialized():
        return None

    # Attempt to unpack into BitmapImageGreyscale8
    bmp = BitmapImageGreyscale8()
    if any_msg.Unpack(bmp):
        return ("BitmapImageGreyscale8", bmp)

    # Otherwise, try to unpack into RangeImage
    rng = RangeImage()
    if any_msg.Unpack(rng):
        return ("RangeImage", rng)

    # If it's neither of the above, return Unknown
    return ("Unknown", any_msg)


def receive_multicast():
    """
    Listen for Sonar 3D-15 UDP multicast packets on a specific port.
    - Filters packets based on the known Sonar IP address.
    - Parses the RIP1 framing.
    - Decodes the Protobuf message.
    - Prints relevant info (e.g. dimension, FoV, timestamp).
    """
    # Set up a UDP socket with multicast membership
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('', PORT))

    group = socket.inet_aton(MULTICAST_GROUP)
    mreq = struct.pack('4sL', group, socket.INADDR_ANY)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)

    print(
        f"Listening for Sonar 3D-15 RIP1 packets on {MULTICAST_GROUP}:{PORT}...")
    print(f"Expecting data only from IP: {SONAR_IP}")
    print("Press Ctrl+C to stop.\n")

    try:
        while True:
            data, addr = sock.recvfrom(BUFFER_SIZE)

            # If this doesn't match the known Sonar IP, skip it.
            if addr[0] != SONAR_IP:
                continue

            # Parse the RIP1 framing to get the Protobuf payload
            payload = parse_rip1_packet(data)
            if payload is None:
                continue  # skip invalid packets

            # Decode the Protobuf message
            result = decode_protobuf_packet(payload)
            if not result:
                print("Unknown or invalid Protobuf message received.")
                continue

            msg_type, msg_obj = result
            print(f"Received '{msg_type}' from {addr}")

            if msg_type == "BitmapImageGreyscale8":
                # Print out main fields
                print("  BitmapImageGreyscale8 data:")
                print(f"    Type: {msg_obj.type}")
                print(
                    f"    Width x Height: {msg_obj.width} x {msg_obj.height}")
                print(f"    Horizontal FoV: {msg_obj.horizontal_fov}")
                print(f"    Vertical FoV:   {msg_obj.vertical_fov}")

                # Header info
                seq_id = msg_obj.header.sequence_id
                dt = msg_obj.header.timestamp.ToDatetime()
                print(f"    Sequence ID:    {seq_id}")
                print(f"    Timestamp (UTC): {dt.isoformat()}")

                # Data
                # print(f"    Data:                {msg_obj.image_pixel_data}")

            elif msg_type == "RangeImage":
                # Print out main fields
                print("  RangeImage data:")
                print(
                    f"    n_pixels_horizontal: {msg_obj.n_pixels_horizontal}")
                print(f"    n_pixels_vertical:   {msg_obj.n_pixels_vertical}")
                print(f"    fov_horizontal:      {msg_obj.fov_horizontal}")
                print(f"    fov_vertical:        {msg_obj.fov_vertical}")
                print(f"    image_pixel_scale:   {msg_obj.image_pixel_scale}")

                # Header info
                seq_id = msg_obj.header.sequence_id
                dt = msg_obj.header.timestamp.ToDatetime()
                print(f"    Sequence ID:         {seq_id}")
                print(f"    Timestamp (UTC):     {dt.isoformat()}")

                # Data
                # print(f"    Data:                {msg_obj.image_pixel_data}")

            else:
                # We don't have a custom handler for other message types
                print(
                    "  Received an unknown message type (not RangeImage or BitmapImage).")

            print()  # Extra blank line for readability

    except KeyboardInterrupt:
        print("\nStopping multicast receiver.")
    finally:
        sock.close()


if __name__ == "__main__":
    receive_multicast()
