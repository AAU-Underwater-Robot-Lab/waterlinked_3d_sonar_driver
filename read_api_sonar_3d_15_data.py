#!/usr/bin/env python3
"""
Simple example script to listen for Sonar 3D-15 data over multicast and print out
the parsed information (including RangeImage and BitmapImageGreyscale8 messages).

REQUIREMENTS:
  - Python 3
  - protobuf (pip install protobuf)
  - sonar_3d_15_protocol_pb2.py generated from the Water Linked sonar .proto file
  - Access to the multicast IP and port used by the Sonar 3D-15
  - Internet/Firewall settings that allow UDP multicast traffic

USAGE:
  1. Place this script (e.g., "sonar_listener.py") in the same folder as the
     "sonar_3d_15_protocol_pb2.py" file (generated by protoc).
  2. Edit SONAR_IP to match your Sonar 3D-15's IP address.
  3. Run: python sonar_listener.py
  4. Observe the output in the terminal.
"""

import socket
import struct
import zlib
import math

# Generated Protobuf definitions for the Sonar 3D-15 protocol
from sonar_3d_15_protocol_pb2 import (
    Packet,
    BitmapImageGreyscale8,
    RangeImage
)

# Multicast group and port used by the Sonar 3D-15
MULTICAST_GROUP = '224.0.0.96'
PORT = 4747

# Listen to all IPs by default, or set to a specific IP.
SONAR_IP = ""

# The maximum possible packet size for Sonar 3D-15 data
BUFFER_SIZE = 65535


def parse_rip1_packet(data: bytes):
    """
    Parse the RIP1 framing:
      1. Verify the "RIP1" magic header
      2. Verify total_length field matches the data size
      3. Check CRC
      4. Extract payload (proto data) from the packet

    Returns:
      payload (bytes) if valid, or None if there's an error.
    """
    if len(data) < 13:
        print(f"Packet too small: only {len(data)} bytes.")
        return None

    # First 4 bytes are "RIP1"
    magic = data[:4]
    if magic != b'RIP1':
        print(f"Invalid magic: got {magic!r} instead of b'RIP1'.")
        return None

    # Next 4 bytes (little-endian) specify the total packet length
    total_length = struct.unpack('<I', data[4:8])[0]
    if len(data) < total_length:
        print(
            f"Packet truncated: needed {total_length} bytes, got {len(data)}.")
        return None

    # The payload is between offset 8 and (total_length - 4)
    payload = data[8: total_length - 4]

    # Last 4 bytes in the packet is the CRC32
    crc_received = struct.unpack('<I', data[total_length - 4: total_length])[0]
    crc_calculated = zlib.crc32(data[: total_length - 4]) & 0xffffffff
    if crc_calculated != crc_received:
        print(
            f"CRC mismatch: expected 0x{crc_calculated:08x}, got 0x{crc_received:08x}.")
        return None

    return payload


def decode_protobuf_packet(payload: bytes):
    """
    Decode the Protobuf Packet (top-level), which may contain:
      - BitmapImageGreyscale8
      - RangeImage
      - or an unknown message type (google.protobuf.Any)

    Returns:
      (msg_type_name, message_object) if successfully parsed,
      or None if parsing failed.
    """
    # Create a top-level Packet object
    packet = Packet()
    try:
        packet.ParseFromString(payload)
    except Exception as e:
        print(f"Protobuf parse error: {e}")
        return None

    # The actual data is in the .msg field (type google.protobuf.Any)
    any_msg = packet.msg
    if not any_msg.IsInitialized():
        return None

    # Attempt to unpack into BitmapImageGreyscale8
    bmp = BitmapImageGreyscale8()
    if any_msg.Unpack(bmp):
        return ("BitmapImageGreyscale8", bmp)

    # Otherwise, try to unpack into RangeImage
    rng = RangeImage()
    if any_msg.Unpack(rng):
        return ("RangeImage", rng)

    # If it's neither of the above, return Unknown
    return ("Unknown", any_msg)


def rangeImageToXYZ(ri):
    """
    Convert RangeImage data to a list of voxels with X, Y, Z coordinates.
    """
    max_pixel_x = ri.width - 1
    max_pixel_y = ri.height - 1
    fov_h = math.radians(ri.fov_horizontal)
    fov_v = math.radians(ri.fov_vertical)

    voxels = []

    for pixel_x in range(ri.width):
        for pixel_y in range(ri.height):
            pixel_value = ri.image_pixel_data[pixel_y * ri.width + pixel_x]
            if pixel_value == 0:
                # No data for this pixel
                continue

            yaw_rad = (pixel_x / max_pixel_x) * fov_h - fov_h / 2
            pitch_rad = (pixel_y / max_pixel_y) * fov_v - fov_v / 2
            distance_meters = pixel_value * ri.image_pixel_scale

            x = distance_meters * math.cos(pitch_rad) * math.cos(yaw_rad)
            y = distance_meters * math.cos(pitch_rad) * math.sin(yaw_rad)
            z = -distance_meters * math.sin(pitch_rad)

            voxel = {
                "yaw": yaw_rad,  # yaw in radians
                "pitch": pitch_rad, # pitch in radians
                "distance": distance_meters, # distance in meters
                "x": x, # x coordinate in meters
                "y": y, # y coordinate in meters
                "z": z # z coordinate in meters
            }

            voxels.append(voxel)
    return voxels


def saveXYZ(voxels, filename):
    """
    Save the list of voxels to a file in XYZ format.
    Each voxel is represented as a line with x, y, z coordinates.
    """
    with open(filename, 'w') as f:
        for voxel in voxels:
            x = voxel['x']
            y = voxel['y']
            z = voxel['z']
            f.write(f"{x} {y} {z}\n")
    print(f"Saved {len(voxels)} voxels to {filename}")

def saveImage(bmpImg):
    """
    Save the BitmapImageGreyscale8 data to a file.
    The data is saved as a grayscale image in PGM format.
    """
    filename = f"sonar_image_{bmpImg.header.sequence_id}.pgm"
    with open(filename, 'wb') as f:
        f.write(b'P2\n') # PGM format identifier
        f.write(f"{bmpImg.width} {bmpImg.height}\n".encode()) # Write the width and height
        f.write(b'255\n')  # Max pixel value for PGM
        # Write pixel data
        for y in range(bmpImg.height-1, 0, -1): # Flip the image vertically
            for x in range(bmpImg.width):
                pixel_value = bmpImg.image_pixel_data[y * bmpImg.width + x]
                f.write(f"{pixel_value} ".encode())
            f.write(b'\n')
    print(f"Saved BitmapImage to {filename}")


def receive_multicast(save: bool = False):
    """
    Listen for Sonar 3D-15 UDP multicast packets on a specific port.
    - Filters packets based on the known Sonar IP address.
    - Parses the RIP1 framing.
    - Decodes the Protobuf message.
    - Prints relevant info (e.g. dimension, FoV, timestamp).
    """
    # Set up a UDP socket with multicast membership
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('', PORT))

    group = socket.inet_aton(MULTICAST_GROUP)
    mreq = struct.pack('4sL', group, socket.INADDR_ANY)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)

    print(
        f"Listening for Sonar 3D-15 RIP1 packets on {MULTICAST_GROUP}:{PORT}...")
    print(f"Expecting data only from IP: {SONAR_IP}")
    print("Press Ctrl+C to stop.\n")

    try:
        while True:
            data, addr = sock.recvfrom(BUFFER_SIZE)

            # If SONAR_IP is configured, and this doesn't match the known Sonar IP, skip it.
            if SONAR_IP != "" and addr[0] != SONAR_IP:
                continue

            # Parse the RIP1 framing to get the Protobuf payload
            payload = parse_rip1_packet(data)
            if payload is None:
                continue  # skip invalid packets

            # Decode the Protobuf message
            result = decode_protobuf_packet(payload)
            if not result:
                print("Unknown or invalid Protobuf message received.")
                continue

            msg_type, msg_obj = result
            print(f"Received '{msg_type}' from {addr}")

            if msg_type == "BitmapImageGreyscale8":
                # Print out main fields
                print("  BitmapImageGreyscale8 data:")
                print(f"    Type: {msg_obj.type}")
                print(f"    Width x Height:  {msg_obj.width} x {msg_obj.height}")
                print(f"    Horizontal FoV:  {msg_obj.fov_horizontal}")
                print(f"    Vertical FoV:    {msg_obj.fov_vertical}")

                # Header info
                seq_id = msg_obj.header.sequence_id
                dt = msg_obj.header.timestamp.ToDatetime()
                print(f"    Sequence ID:     {seq_id}")
                print(f"    Timestamp (UTC): {dt.isoformat()}")

                # Data
                if save:
                    saveImage(msg_obj)

            elif msg_type == "RangeImage":
                # Print out main fields
                print("  RangeImage data:")
                print(f"    Width x Height:    {msg_obj.width} x {msg_obj.height}")
                print(f"    Horizontal FoV:    {msg_obj.fov_horizontal}")
                print(f"    Vertical FoV:      {msg_obj.fov_vertical}")
                print(f"    image_pixel_scale: {msg_obj.image_pixel_scale}")

                # Header info
                seq_id = msg_obj.header.sequence_id
                dt = msg_obj.header.timestamp.ToDatetime()
                print(f"    Sequence ID:         {seq_id}")
                print(f"    Timestamp (UTC):     {dt.isoformat()}")

                # Convert to XYZ coordinates
                voxels = rangeImageToXYZ(msg_obj)
                print(f"    Voxel count:         {len(voxels)}")
                if save:
                    # Save to XYZ file
                    filename = f"sonar_voxels_{seq_id}.xyz"
                    saveXYZ(voxels, filename)

            else:
                # We don't have a custom handler for other message types
                print(
                    "  Received an unknown message type (not RangeImage or BitmapImage).")

            print()  # Extra blank line for readability

    except KeyboardInterrupt:
        print("\nStopping multicast receiver.")
    finally:
        sock.close()


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(
        description="Listen for Sonar 3D-15 data over multicast.")
    parser.add_argument(
        "--save",
        action="store_true",
        help="Save RangeImage data to XYZ file format and BitmapImage to PGM file format."
    )
    parser.add_argument(
        "--ip",
        type=str,
        default="",
        help="Limit to packets from this IP address (default: all)."
    )
    # Parse arguments
    args = parser.parse_args()
    if args.ip:
        SONAR_IP = args.ip
    receive_multicast(args.save)
